"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/auth/login/page",{

/***/ "(app-pages-browser)/./utils/errorHandler.js":
/*!*******************************!*\
  !*** ./utils/errorHandler.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorTypes: function() { return /* binding */ ErrorTypes; },\n/* harmony export */   createError: function() { return /* binding */ createError; },\n/* harmony export */   getErrorMessage: function() { return /* binding */ getErrorMessage; },\n/* harmony export */   getErrorType: function() { return /* binding */ getErrorType; },\n/* harmony export */   getRetryDelay: function() { return /* binding */ getRetryDelay; },\n/* harmony export */   handleApiError: function() { return /* binding */ handleApiError; },\n/* harmony export */   isRetryableError: function() { return /* binding */ isRetryableError; },\n/* harmony export */   logError: function() { return /* binding */ logError; },\n/* harmony export */   setTranslationFunction: function() { return /* binding */ setTranslationFunction; }\n/* harmony export */ });\n/**\r\n * Comprehensive Error Handling Utility\r\n * Provides consistent error handling across the application\r\n * Works in both development and production environments\r\n */ const isDevelopment = \"development\" === \"development\";\n// Translation function - will be set by useTranslation hook\nlet translateFunction = null;\n/**\r\n * Set the translation function\r\n */ const setTranslationFunction = (t)=>{\n    translateFunction = t;\n};\n/**\r\n * Get translated error message\r\n */ const getTranslatedError = (key, fallback)=>{\n    if (translateFunction && typeof translateFunction === \"function\") {\n        const translated = translateFunction(\"errors.\".concat(key));\n        // If translation returns the key (not found), use fallback\n        return translated !== \"errors.\".concat(key) ? translated : fallback;\n    }\n    return fallback;\n};\n/**\r\n * Error types enum\r\n */ const ErrorTypes = {\n    NETWORK: \"NETWORK_ERROR\",\n    TIMEOUT: \"TIMEOUT_ERROR\",\n    AUTH: \"AUTH_ERROR\",\n    VALIDATION: \"VALIDATION_ERROR\",\n    SERVER: \"SERVER_ERROR\",\n    CLIENT: \"CLIENT_ERROR\",\n    UNKNOWN: \"UNKNOWN_ERROR\"\n};\n/**\r\n * Get user-friendly error message based on error type\r\n */ const getErrorMessage = function(error) {\n    let defaultMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"An unexpected error occurred\";\n    // If it's already a user-friendly string, return it\n    if (typeof error === \"string\") {\n        return error;\n    }\n    // Handle Axios errors\n    if (error === null || error === void 0 ? void 0 : error.response) {\n        var _error_response_data;\n        const status = error.response.status;\n        const serverMessage = (_error_response_data = error.response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message;\n        // Use server message if available\n        if (serverMessage) {\n            return serverMessage;\n        }\n        // Fallback to status-based messages\n        switch(status){\n            case 400:\n                return \"Invalid request. Please check your input and try again.\";\n            case 401:\n                return \"Your session has expired. Please log in again.\";\n            case 403:\n                return \"You do not have permission to perform this action.\";\n            case 404:\n                return \"The requested resource was not found.\";\n            case 409:\n                return \"This action conflicts with existing data.\";\n            case 422:\n                return \"Validation error. Please check your input.\";\n            case 429:\n                return \"Too many requests. Please try again later.\";\n            case 500:\n                var _error_response_data1;\n                return isDevelopment ? \"Server error: \".concat(((_error_response_data1 = error.response.data) === null || _error_response_data1 === void 0 ? void 0 : _error_response_data1.error) || \"Internal server error\") : \"Server error. Please try again later or contact support.\";\n            case 502:\n                return \"Service temporarily unavailable. Please try again later.\";\n            case 503:\n                return \"Service is currently unavailable. Please try again later.\";\n            default:\n                return isDevelopment ? \"Error \".concat(status, \": \").concat(serverMessage || \"Unknown error\") : \"An error occurred. Please try again.\";\n        }\n    }\n    // Handle network errors\n    if (error === null || error === void 0 ? void 0 : error.request) {\n        var _error_message, _error_message1;\n        if (error.code === \"ECONNABORTED\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"timeout\"))) {\n            return \"Request timed out. Please check your internet connection and try again.\";\n        }\n        if (error.code === \"ERR_NETWORK\" || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"Network Error\"))) {\n            return \"Network error. Please check your internet connection and ensure the server is running.\";\n        }\n        if (error.code === \"ERR_CORS\") {\n            return \"CORS error. Please contact support if this persists.\";\n        }\n        return \"Unable to connect to server. Please check your internet connection.\";\n    }\n    // Handle validation errors\n    if ((error === null || error === void 0 ? void 0 : error.name) === \"ValidationError\") {\n        return error.message || \"Validation error. Please check your input.\";\n    }\n    // Handle generic errors\n    if (error === null || error === void 0 ? void 0 : error.message) {\n        // In development, show full error message\n        if (isDevelopment) {\n            return error.message;\n        }\n        // In production, sanitize error messages\n        if (error.message.includes(\"Network\") || error.message.includes(\"timeout\")) {\n            return \"Network error. Please check your connection.\";\n        }\n        return defaultMessage;\n    }\n    return defaultMessage;\n};\n/**\r\n * Get error type from error object\r\n */ const getErrorType = (error)=>{\n    if (error === null || error === void 0 ? void 0 : error.response) {\n        const status = error.response.status;\n        if (status === 401 || status === 403) {\n            return ErrorTypes.AUTH;\n        }\n        if (status >= 500) {\n            return ErrorTypes.SERVER;\n        }\n        if (status >= 400) {\n            return ErrorTypes.CLIENT;\n        }\n    }\n    if (error === null || error === void 0 ? void 0 : error.request) {\n        var _error_message;\n        if (error.code === \"ECONNABORTED\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"timeout\"))) {\n            return ErrorTypes.TIMEOUT;\n        }\n        return ErrorTypes.NETWORK;\n    }\n    if ((error === null || error === void 0 ? void 0 : error.name) === \"ValidationError\") {\n        return ErrorTypes.VALIDATION;\n    }\n    return ErrorTypes.UNKNOWN;\n};\n/**\r\n * Log error with appropriate level\r\n */ const logError = function(error) {\n    let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const errorType = getErrorType(error);\n    const errorMessage = getErrorMessage(error);\n    const errorDetails = {\n        type: errorType,\n        message: errorMessage,\n        context,\n        timestamp: new Date().toISOString()\n    };\n    // In development, log full error details\n    if (isDevelopment) {\n        var _error_response;\n        console.error(\"Error Details:\", {\n            ...errorDetails,\n            originalError: error,\n            stack: error === null || error === void 0 ? void 0 : error.stack,\n            response: error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data\n        });\n    } else {\n        // In production, log sanitized error\n        console.error(\"Error:\", errorDetails);\n    }\n    // TODO: Send to error tracking service (e.g., Sentry) in production\n    // if (!isDevelopment && window.Sentry) {\n    //   window.Sentry.captureException(error, { extra: context });\n    // }\n    return errorDetails;\n};\n/**\r\n * Handle API error with user-friendly message\r\n */ const handleApiError = function(error) {\n    let customMessage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    var _error_response, _error_response1, _error_message;\n    const errorDetails = logError(error, {\n        source: \"API\"\n    });\n    return {\n        message: customMessage || errorDetails.message,\n        type: errorDetails.type,\n        status: error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n        data: error === null || error === void 0 ? void 0 : (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.data,\n        isNetworkError: !(error === null || error === void 0 ? void 0 : error.response) && (error === null || error === void 0 ? void 0 : error.request),\n        isTimeout: (error === null || error === void 0 ? void 0 : error.code) === \"ECONNABORTED\" || (error === null || error === void 0 ? void 0 : (_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"timeout\"))\n    };\n};\n/**\r\n * Create error object with consistent structure\r\n */ const createError = function(message) {\n    let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ErrorTypes.UNKNOWN, details = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return {\n        message,\n        type,\n        details,\n        timestamp: new Date().toISOString()\n    };\n};\n/**\r\n * Check if error is retryable\r\n */ const isRetryableError = (error)=>{\n    var _error_response, _error_message, _error_response1;\n    // Network errors are usually retryable\n    if (!(error === null || error === void 0 ? void 0 : error.response) && (error === null || error === void 0 ? void 0 : error.request)) {\n        return true;\n    }\n    // 5xx errors are retryable\n    if ((error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) >= 500) {\n        return true;\n    }\n    // Timeout errors are retryable\n    if ((error === null || error === void 0 ? void 0 : error.code) === \"ECONNABORTED\" || (error === null || error === void 0 ? void 0 : (_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"timeout\"))) {\n        return true;\n    }\n    // 429 (Too Many Requests) is retryable after delay\n    if ((error === null || error === void 0 ? void 0 : (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) === 429) {\n        return true;\n    }\n    return false;\n};\n/**\r\n * Get retry delay in milliseconds\r\n */ const getRetryDelay = function() {\n    let attempt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, baseDelay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1000;\n    // Exponential backoff: 1s, 2s, 4s, 8s, etc.\n    return Math.min(baseDelay * Math.pow(2, attempt - 1), 30000); // Max 30 seconds\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2Vycm9ySGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBRUQsTUFBTUEsZ0JBQWdCQyxrQkFBeUI7QUFFL0MsNERBQTREO0FBQzVELElBQUlDLG9CQUFvQjtBQUV4Qjs7Q0FFQyxHQUNNLE1BQU1DLHlCQUF5QixDQUFDQztJQUNyQ0Ysb0JBQW9CRTtBQUN0QixFQUFFO0FBRUY7O0NBRUMsR0FDRCxNQUFNQyxxQkFBcUIsQ0FBQ0MsS0FBS0M7SUFDL0IsSUFBSUwscUJBQXFCLE9BQU9BLHNCQUFzQixZQUFZO1FBQ2hFLE1BQU1NLGFBQWFOLGtCQUFrQixVQUFjLE9BQUpJO1FBQy9DLDJEQUEyRDtRQUMzRCxPQUFPRSxlQUFlLFVBQWMsT0FBSkYsT0FBUUUsYUFBYUQ7SUFDdkQ7SUFDQSxPQUFPQTtBQUNUO0FBRUE7O0NBRUMsR0FDTSxNQUFNRSxhQUFhO0lBQ3hCQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxZQUFZO0lBQ1pDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxTQUFTO0FBQ1gsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTUMsa0JBQWtCLFNBQUNDO1FBQU9DLGtGQUFpQjtJQUN0RCxvREFBb0Q7SUFDcEQsSUFBSSxPQUFPRCxVQUFVLFVBQVU7UUFDN0IsT0FBT0E7SUFDVDtJQUVBLHNCQUFzQjtJQUN0QixJQUFJQSxrQkFBQUEsNEJBQUFBLE1BQU9FLFFBQVEsRUFBRTtZQUVHRjtRQUR0QixNQUFNRyxTQUFTSCxNQUFNRSxRQUFRLENBQUNDLE1BQU07UUFDcEMsTUFBTUMsaUJBQWdCSix1QkFBQUEsTUFBTUUsUUFBUSxDQUFDRyxJQUFJLGNBQW5CTCwyQ0FBQUEscUJBQXFCTSxPQUFPO1FBRWxELGtDQUFrQztRQUNsQyxJQUFJRixlQUFlO1lBQ2pCLE9BQU9BO1FBQ1Q7UUFFQSxvQ0FBb0M7UUFDcEMsT0FBUUQ7WUFDTixLQUFLO2dCQUNILE9BQU87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QUdKLFVBQVUsSUFBSSxRQUFRLGlCQUFpQjtBQUNqRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2Vycm9ySGFuZGxlci5qcz8wY2RmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb21wcmVoZW5zaXZlIEVycm9yIEhhbmRsaW5nIFV0aWxpdHlcclxuICogUHJvdmlkZXMgY29uc2lzdGVudCBlcnJvciBoYW5kbGluZyBhY3Jvc3MgdGhlIGFwcGxpY2F0aW9uXHJcbiAqIFdvcmtzIGluIGJvdGggZGV2ZWxvcG1lbnQgYW5kIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzXHJcbiAqL1xyXG5cclxuY29uc3QgaXNEZXZlbG9wbWVudCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xyXG5cclxuLy8gVHJhbnNsYXRpb24gZnVuY3Rpb24gLSB3aWxsIGJlIHNldCBieSB1c2VUcmFuc2xhdGlvbiBob29rXHJcbmxldCB0cmFuc2xhdGVGdW5jdGlvbiA9IG51bGw7XHJcblxyXG4vKipcclxuICogU2V0IHRoZSB0cmFuc2xhdGlvbiBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNldFRyYW5zbGF0aW9uRnVuY3Rpb24gPSAodCkgPT4ge1xyXG4gIHRyYW5zbGF0ZUZ1bmN0aW9uID0gdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdHJhbnNsYXRlZCBlcnJvciBtZXNzYWdlXHJcbiAqL1xyXG5jb25zdCBnZXRUcmFuc2xhdGVkRXJyb3IgPSAoa2V5LCBmYWxsYmFjaykgPT4ge1xyXG4gIGlmICh0cmFuc2xhdGVGdW5jdGlvbiAmJiB0eXBlb2YgdHJhbnNsYXRlRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGNvbnN0IHRyYW5zbGF0ZWQgPSB0cmFuc2xhdGVGdW5jdGlvbihgZXJyb3JzLiR7a2V5fWApO1xyXG4gICAgLy8gSWYgdHJhbnNsYXRpb24gcmV0dXJucyB0aGUga2V5IChub3QgZm91bmQpLCB1c2UgZmFsbGJhY2tcclxuICAgIHJldHVybiB0cmFuc2xhdGVkICE9PSBgZXJyb3JzLiR7a2V5fWAgPyB0cmFuc2xhdGVkIDogZmFsbGJhY2s7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxsYmFjaztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFcnJvciB0eXBlcyBlbnVtXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRXJyb3JUeXBlcyA9IHtcclxuICBORVRXT1JLOiAnTkVUV09SS19FUlJPUicsXHJcbiAgVElNRU9VVDogJ1RJTUVPVVRfRVJST1InLFxyXG4gIEFVVEg6ICdBVVRIX0VSUk9SJyxcclxuICBWQUxJREFUSU9OOiAnVkFMSURBVElPTl9FUlJPUicsXHJcbiAgU0VSVkVSOiAnU0VSVkVSX0VSUk9SJyxcclxuICBDTElFTlQ6ICdDTElFTlRfRVJST1InLFxyXG4gIFVOS05PV046ICdVTktOT1dOX0VSUk9SJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdXNlci1mcmllbmRseSBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIGVycm9yIHR5cGVcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRFcnJvck1lc3NhZ2UgPSAoZXJyb3IsIGRlZmF1bHRNZXNzYWdlID0gJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQnKSA9PiB7XHJcbiAgLy8gSWYgaXQncyBhbHJlYWR5IGEgdXNlci1mcmllbmRseSBzdHJpbmcsIHJldHVybiBpdFxyXG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbiAgfVxyXG5cclxuICAvLyBIYW5kbGUgQXhpb3MgZXJyb3JzXHJcbiAgaWYgKGVycm9yPy5yZXNwb25zZSkge1xyXG4gICAgY29uc3Qgc3RhdHVzID0gZXJyb3IucmVzcG9uc2Uuc3RhdHVzO1xyXG4gICAgY29uc3Qgc2VydmVyTWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlLmRhdGE/Lm1lc3NhZ2U7XHJcblxyXG4gICAgLy8gVXNlIHNlcnZlciBtZXNzYWdlIGlmIGF2YWlsYWJsZVxyXG4gICAgaWYgKHNlcnZlck1lc3NhZ2UpIHtcclxuICAgICAgcmV0dXJuIHNlcnZlck1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmFsbGJhY2sgdG8gc3RhdHVzLWJhc2VkIG1lc3NhZ2VzXHJcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xyXG4gICAgICBjYXNlIDQwMDpcclxuICAgICAgICByZXR1cm4gJ0ludmFsaWQgcmVxdWVzdC4gUGxlYXNlIGNoZWNrIHlvdXIgaW5wdXQgYW5kIHRyeSBhZ2Fpbi4nO1xyXG4gICAgICBjYXNlIDQwMTpcclxuICAgICAgICByZXR1cm4gJ1lvdXIgc2Vzc2lvbiBoYXMgZXhwaXJlZC4gUGxlYXNlIGxvZyBpbiBhZ2Fpbi4nO1xyXG4gICAgICBjYXNlIDQwMzpcclxuICAgICAgICByZXR1cm4gJ1lvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb24uJztcclxuICAgICAgY2FzZSA0MDQ6XHJcbiAgICAgICAgcmV0dXJuICdUaGUgcmVxdWVzdGVkIHJlc291cmNlIHdhcyBub3QgZm91bmQuJztcclxuICAgICAgY2FzZSA0MDk6XHJcbiAgICAgICAgcmV0dXJuICdUaGlzIGFjdGlvbiBjb25mbGljdHMgd2l0aCBleGlzdGluZyBkYXRhLic7XHJcbiAgICAgIGNhc2UgNDIyOlxyXG4gICAgICAgIHJldHVybiAnVmFsaWRhdGlvbiBlcnJvci4gUGxlYXNlIGNoZWNrIHlvdXIgaW5wdXQuJztcclxuICAgICAgY2FzZSA0Mjk6XHJcbiAgICAgICAgcmV0dXJuICdUb28gbWFueSByZXF1ZXN0cy4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nO1xyXG4gICAgICBjYXNlIDUwMDpcclxuICAgICAgICByZXR1cm4gaXNEZXZlbG9wbWVudFxyXG4gICAgICAgICAgPyBgU2VydmVyIGVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGE/LmVycm9yIHx8ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InfWBcclxuICAgICAgICAgIDogJ1NlcnZlciBlcnJvci4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlciBvciBjb250YWN0IHN1cHBvcnQuJztcclxuICAgICAgY2FzZSA1MDI6XHJcbiAgICAgICAgcmV0dXJuICdTZXJ2aWNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLic7XHJcbiAgICAgIGNhc2UgNTAzOlxyXG4gICAgICAgIHJldHVybiAnU2VydmljZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gaXNEZXZlbG9wbWVudFxyXG4gICAgICAgICAgPyBgRXJyb3IgJHtzdGF0dXN9OiAke3NlcnZlck1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWBcclxuICAgICAgICAgIDogJ0FuIGVycm9yIG9jY3VycmVkLiBQbGVhc2UgdHJ5IGFnYWluLic7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBIYW5kbGUgbmV0d29yayBlcnJvcnNcclxuICBpZiAoZXJyb3I/LnJlcXVlc3QpIHtcclxuICAgIGlmIChlcnJvci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygndGltZW91dCcpKSB7XHJcbiAgICAgIHJldHVybiAnUmVxdWVzdCB0aW1lZCBvdXQuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24gYW5kIHRyeSBhZ2Fpbi4nO1xyXG4gICAgfVxyXG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdFUlJfTkVUV09SSycgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ05ldHdvcmsgRXJyb3InKSkge1xyXG4gICAgICByZXR1cm4gJ05ldHdvcmsgZXJyb3IuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24gYW5kIGVuc3VyZSB0aGUgc2VydmVyIGlzIHJ1bm5pbmcuJztcclxuICAgIH1cclxuICAgIGlmIChlcnJvci5jb2RlID09PSAnRVJSX0NPUlMnKSB7XHJcbiAgICAgIHJldHVybiAnQ09SUyBlcnJvci4gUGxlYXNlIGNvbnRhY3Qgc3VwcG9ydCBpZiB0aGlzIHBlcnNpc3RzLic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ1VuYWJsZSB0byBjb25uZWN0IHRvIHNlcnZlci4gUGxlYXNlIGNoZWNrIHlvdXIgaW50ZXJuZXQgY29ubmVjdGlvbi4nO1xyXG4gIH1cclxuXHJcbiAgLy8gSGFuZGxlIHZhbGlkYXRpb24gZXJyb3JzXHJcbiAgaWYgKGVycm9yPy5uYW1lID09PSAnVmFsaWRhdGlvbkVycm9yJykge1xyXG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2UgfHwgJ1ZhbGlkYXRpb24gZXJyb3IuIFBsZWFzZSBjaGVjayB5b3VyIGlucHV0Lic7XHJcbiAgfVxyXG5cclxuICAvLyBIYW5kbGUgZ2VuZXJpYyBlcnJvcnNcclxuICBpZiAoZXJyb3I/Lm1lc3NhZ2UpIHtcclxuICAgIC8vIEluIGRldmVsb3BtZW50LCBzaG93IGZ1bGwgZXJyb3IgbWVzc2FnZVxyXG4gICAgaWYgKGlzRGV2ZWxvcG1lbnQpIHtcclxuICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCBzYW5pdGl6ZSBlcnJvciBtZXNzYWdlc1xyXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ05ldHdvcmsnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcclxuICAgICAgcmV0dXJuICdOZXR3b3JrIGVycm9yLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVmYXVsdE1lc3NhZ2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGVmYXVsdE1lc3NhZ2U7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGVycm9yIHR5cGUgZnJvbSBlcnJvciBvYmplY3RcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRFcnJvclR5cGUgPSAoZXJyb3IpID0+IHtcclxuICBpZiAoZXJyb3I/LnJlc3BvbnNlKSB7XHJcbiAgICBjb25zdCBzdGF0dXMgPSBlcnJvci5yZXNwb25zZS5zdGF0dXM7XHJcbiAgICBpZiAoc3RhdHVzID09PSA0MDEgfHwgc3RhdHVzID09PSA0MDMpIHtcclxuICAgICAgcmV0dXJuIEVycm9yVHlwZXMuQVVUSDtcclxuICAgIH1cclxuICAgIGlmIChzdGF0dXMgPj0gNTAwKSB7XHJcbiAgICAgIHJldHVybiBFcnJvclR5cGVzLlNFUlZFUjtcclxuICAgIH1cclxuICAgIGlmIChzdGF0dXMgPj0gNDAwKSB7XHJcbiAgICAgIHJldHVybiBFcnJvclR5cGVzLkNMSUVOVDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChlcnJvcj8ucmVxdWVzdCkge1xyXG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTkFCT1JURUQnIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcclxuICAgICAgcmV0dXJuIEVycm9yVHlwZXMuVElNRU9VVDtcclxuICAgIH1cclxuICAgIHJldHVybiBFcnJvclR5cGVzLk5FVFdPUks7XHJcbiAgfVxyXG5cclxuICBpZiAoZXJyb3I/Lm5hbWUgPT09ICdWYWxpZGF0aW9uRXJyb3InKSB7XHJcbiAgICByZXR1cm4gRXJyb3JUeXBlcy5WQUxJREFUSU9OO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEVycm9yVHlwZXMuVU5LTk9XTjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb2cgZXJyb3Igd2l0aCBhcHByb3ByaWF0ZSBsZXZlbFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxvZ0Vycm9yID0gKGVycm9yLCBjb250ZXh0ID0ge30pID0+IHtcclxuICBjb25zdCBlcnJvclR5cGUgPSBnZXRFcnJvclR5cGUoZXJyb3IpO1xyXG4gIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZShlcnJvcik7XHJcbiAgY29uc3QgZXJyb3JEZXRhaWxzID0ge1xyXG4gICAgdHlwZTogZXJyb3JUeXBlLFxyXG4gICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxyXG4gICAgY29udGV4dCxcclxuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH07XHJcblxyXG4gIC8vIEluIGRldmVsb3BtZW50LCBsb2cgZnVsbCBlcnJvciBkZXRhaWxzXHJcbiAgaWYgKGlzRGV2ZWxvcG1lbnQpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIERldGFpbHM6Jywge1xyXG4gICAgICAuLi5lcnJvckRldGFpbHMsXHJcbiAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yLFxyXG4gICAgICBzdGFjazogZXJyb3I/LnN0YWNrLFxyXG4gICAgICByZXNwb25zZTogZXJyb3I/LnJlc3BvbnNlPy5kYXRhLFxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIEluIHByb2R1Y3Rpb24sIGxvZyBzYW5pdGl6ZWQgZXJyb3JcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOicsIGVycm9yRGV0YWlscyk7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBTZW5kIHRvIGVycm9yIHRyYWNraW5nIHNlcnZpY2UgKGUuZy4sIFNlbnRyeSkgaW4gcHJvZHVjdGlvblxyXG4gIC8vIGlmICghaXNEZXZlbG9wbWVudCAmJiB3aW5kb3cuU2VudHJ5KSB7XHJcbiAgLy8gICB3aW5kb3cuU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oZXJyb3IsIHsgZXh0cmE6IGNvbnRleHQgfSk7XHJcbiAgLy8gfVxyXG5cclxuICByZXR1cm4gZXJyb3JEZXRhaWxzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZSBBUEkgZXJyb3Igd2l0aCB1c2VyLWZyaWVuZGx5IG1lc3NhZ2VcclxuICovXHJcbmV4cG9ydCBjb25zdCBoYW5kbGVBcGlFcnJvciA9IChlcnJvciwgY3VzdG9tTWVzc2FnZSA9IG51bGwpID0+IHtcclxuICBjb25zdCBlcnJvckRldGFpbHMgPSBsb2dFcnJvcihlcnJvciwgeyBzb3VyY2U6ICdBUEknIH0pO1xyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBtZXNzYWdlOiBjdXN0b21NZXNzYWdlIHx8IGVycm9yRGV0YWlscy5tZXNzYWdlLFxyXG4gICAgdHlwZTogZXJyb3JEZXRhaWxzLnR5cGUsXHJcbiAgICBzdGF0dXM6IGVycm9yPy5yZXNwb25zZT8uc3RhdHVzLFxyXG4gICAgZGF0YTogZXJyb3I/LnJlc3BvbnNlPy5kYXRhLFxyXG4gICAgaXNOZXR3b3JrRXJyb3I6ICFlcnJvcj8ucmVzcG9uc2UgJiYgZXJyb3I/LnJlcXVlc3QsXHJcbiAgICBpc1RpbWVvdXQ6IGVycm9yPy5jb2RlID09PSAnRUNPTk5BQk9SVEVEJyB8fCBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ3RpbWVvdXQnKSxcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBlcnJvciBvYmplY3Qgd2l0aCBjb25zaXN0ZW50IHN0cnVjdHVyZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUVycm9yID0gKG1lc3NhZ2UsIHR5cGUgPSBFcnJvclR5cGVzLlVOS05PV04sIGRldGFpbHMgPSB7fSkgPT4ge1xyXG4gIHJldHVybiB7XHJcbiAgICBtZXNzYWdlLFxyXG4gICAgdHlwZSxcclxuICAgIGRldGFpbHMsXHJcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGVycm9yIGlzIHJldHJ5YWJsZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzUmV0cnlhYmxlRXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAvLyBOZXR3b3JrIGVycm9ycyBhcmUgdXN1YWxseSByZXRyeWFibGVcclxuICBpZiAoIWVycm9yPy5yZXNwb25zZSAmJiBlcnJvcj8ucmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyA1eHggZXJyb3JzIGFyZSByZXRyeWFibGVcclxuICBpZiAoZXJyb3I/LnJlc3BvbnNlPy5zdGF0dXMgPj0gNTAwKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVvdXQgZXJyb3JzIGFyZSByZXRyeWFibGVcclxuICBpZiAoZXJyb3I/LmNvZGUgPT09ICdFQ09OTkFCT1JURUQnIHx8IGVycm9yPy5tZXNzYWdlPy5pbmNsdWRlcygndGltZW91dCcpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIDQyOSAoVG9vIE1hbnkgUmVxdWVzdHMpIGlzIHJldHJ5YWJsZSBhZnRlciBkZWxheVxyXG4gIGlmIChlcnJvcj8ucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDI5KSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgcmV0cnkgZGVsYXkgaW4gbWlsbGlzZWNvbmRzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0UmV0cnlEZWxheSA9IChhdHRlbXB0ID0gMSwgYmFzZURlbGF5ID0gMTAwMCkgPT4ge1xyXG4gIC8vIEV4cG9uZW50aWFsIGJhY2tvZmY6IDFzLCAycywgNHMsIDhzLCBldGMuXHJcbiAgcmV0dXJuIE1hdGgubWluKGJhc2VEZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSwgMzAwMDApOyAvLyBNYXggMzAgc2Vjb25kc1xyXG59O1xyXG5cclxuIl0sIm5hbWVzIjpbImlzRGV2ZWxvcG1lbnQiLCJwcm9jZXNzIiwidHJhbnNsYXRlRnVuY3Rpb24iLCJzZXRUcmFuc2xhdGlvbkZ1bmN0aW9uIiwidCIsImdldFRyYW5zbGF0ZWRFcnJvciIsImtleSIsImZhbGxiYWNrIiwidHJhbnNsYXRlZCIsIkVycm9yVHlwZXMiLCJORVRXT1JLIiwiVElNRU9VVCIsIkFVVEgiLCJWQUxJREFUSU9OIiwiU0VSVkVSIiwiQ0xJRU5UIiwiVU5LTk9XTiIsImdldEVycm9yTWVzc2FnZSIsImVycm9yIiwiZGVmYXVsdE1lc3NhZ2UiLCJyZXNwb25zZSIsInN0YXR1cyIsInNlcnZlck1lc3NhZ2UiLCJkYXRhIiwibWVzc2FnZSIsInJlcXVlc3QiLCJjb2RlIiwiaW5jbHVkZXMiLCJuYW1lIiwiZ2V0RXJyb3JUeXBlIiwibG9nRXJyb3IiLCJjb250ZXh0IiwiZXJyb3JUeXBlIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JEZXRhaWxzIiwidHlwZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbnNvbGUiLCJvcmlnaW5hbEVycm9yIiwic3RhY2siLCJoYW5kbGVBcGlFcnJvciIsImN1c3RvbU1lc3NhZ2UiLCJzb3VyY2UiLCJpc05ldHdvcmtFcnJvciIsImlzVGltZW91dCIsImNyZWF0ZUVycm9yIiwiZGV0YWlscyIsImlzUmV0cnlhYmxlRXJyb3IiLCJnZXRSZXRyeURlbGF5IiwiYXR0ZW1wdCIsImJhc2VEZWxheSIsIk1hdGgiLCJtaW4iLCJwb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/errorHandler.js\n"));

/***/ })

});